<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithms | 50a23bb7]]></title>
  <link href="http://zellux.github.com/blog/categories/algorithms/atom.xml" rel="self"/>
  <link href="http://zellux.github.com/"/>
  <updated>2012-09-01T00:26:39+08:00</updated>
  <id>http://zellux.github.com/</id>
  <author>
    <name><![CDATA[zellux]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Solutions to CLRS Chapter 32.1]]></title>
    <link href="http://zellux.github.com/blog/2012/08/solution-to-clrs-chapter-32/"/>
    <updated>2012-08-22T22:22:00+08:00</updated>
    <id>http://zellux.github.com/blog/2012/08/solution-to-clrs-chapter-32</id>
    <content type="html"><![CDATA[<h2>Problem 32.1-2</h2>

<blockquote><p>Suppose that all characters in the pattern P are different. Show how to accelerate NAIVE-STRING-MATCHER to run in time O(n) on an n-character text T .</p></blockquote>

<p>When T[i] and P[j] mismatches in NAIVE-STRING-MATCHER, we can skip all characters before T[i] and begin new matching from T[i + 1] with P[1].</p>

<h2>Problem 32.1-4</h2>

<blockquote><p>  Suppose we allow the pattern P to contain occurrences of a gap character ◇ that can match an arbitrary string of characters (even one of zero length). Note that the gap character may occur an arbitrary number of times in the pattern but not at all in the text. Give a polynomial-time algorithm to determine whether such a pattern P occurs in a given text T , and analyze the running time of your algorithm.</p></blockquote>

<p>We can solve this problem using dynamic programming. Assume we have function F(T<sub>i</sub>, P<sub>j</sub>), which defines whether the subpattern P<sub>j</sub> matches T<sub>i</sub>, and its value can be deducted from three sub-problems:</p>

<ol>
<li>P[j] == ◇ AND F(T<sub>i-1</sub>, P<sub>j</sub>)</li>
<li>P[j] == ◇ AND F(T<sub>i</sub>, P<sub>j-1</sub>)</li>
<li>F(T<sub>i-1</sub>, P<sub>j-1</sub>)</li>
</ol>


<p>F(T<sub>i</sub>, P<sub>j</sub>) is true, if and only if any of the above statements is true. The problem can thus be sovled in O(n ^ 2) in a bottom-up way.</p>
]]></content>
  </entry>
  
</feed>
